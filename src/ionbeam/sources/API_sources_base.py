import dataclasses
from ..core.bases import Message, Source
from pathlib import Path
from typing import Iterable, Any
import logging
from datetime import datetime
logger = logging.getLogger(__name__)

class API_Error(Exception): pass

@dataclasses.dataclass
class APISource(Source):
    """
    A base class to contain generic logic related to sources that periodically query API endpoints.


    .generate() is defined by the this base class, derived classes should define:
    
    def init(self, globals):
        super().init(globals)
        ...

    def query(self, start_date, end_date) -> List[Message]
    """
    secrets_file: Path = Path("secrets.yaml")

    "The time interval to ingest, can be overridden by globals.source_timespan"
    start_date: str = "2022-01-01"
    end_date: str = "2023-11-30"

    finish_after: int | None = None

    def init(self, globals):
        super().init(globals)
        
        # If the timespan of interest is being overridden
        if self.globals and self.globals.ingestion_time_constants is not None:
            self.start_date, self.end_date = self.globals.ingestion_time_constants.query_timespan
        else:
            self.start_date = datetime.fromisoformat(self.start_date)
            self.end_date = datetime.fromisoformat(self.end_date)

        self.cache_directory = self.resolve_path(self.cache_directory, type="data")

    def get_chunks(self, start_date : datetime, end_date: datetime) -> Iterable[Any]:
        """
        Return an iterable of objects representing chunks of data we should download from the API
        The return type can be an iterable of anything, eg strings representing session IDs
        It could also be the raw data if the API is structured that way.
        """
        raise NotImplementedError

    def download_chunk(self, chunk : Any) -> Iterable[Message]:
        """
        Take a chunk generated by get_chunks and download it to produce a message or messages.
        """
        raise NotImplementedError

    def generate(self) -> Iterable[Message]:
        emitted_messages = 0

        for chunk in self.get_chunks(self.start_date, self.end_date):
            try:
                messages = self.download_chunk(chunk)
            except API_Error as e:
                logger.warning(f"{self.__class__.__name__}.get_chunks failed for {chunk = }\n{e}")
                continue

            for message in messages:
                yield message
                emitted_messages += 1
                if self.finish_after is not None and emitted_messages >= self.finish_after:
                    return